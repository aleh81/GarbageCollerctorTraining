using System;

namespace GarbageCollector.Part2
{
    //Наследуем интерфейс IDisposeble чтобы установить контракт для логики
    //которая освобождает неуправляемые ресурсы
    internal class Car : IDisposable
    {
        /*Альтернативный и пожалуй лучший вариант освобождения ресурсов чем в Part1, почему?
         Да потому что мы не беспокоим Garbage Collector а он не вешает наш апликэйшн*/
        public void Dispose()
        {
            Console.WriteLine("Вызван деструктор обьекта класса Car");
            Console.Beep();
            /*Тут мы например закрываем подключение к БД*/
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            BadApproach();

            BetterApproach();

            TheBestApproach();

            Console.ReadKey();
        }

        /*Плохой подход так как мы можем забыть в коде вручную вызвать Dispose,
         и САМАЯ ВАЖНАЯ проблема в том что если программа выкинет исключение ресурсы не
         освободяться (например подключение к БД не закроется)*/
        private static void BadApproach()
        {
            var car = new Car();

            car.Dispose();
        }

        /*Конструкця try...finally гарантирует что даже если возникнет исключение, сработает метод
         Dispose() обьекта car который освободит неуправляемые ресурсы связанные с этим объектом.
         Но вам не кажется что конструкция немного громоздкая и плохо читается код?*/
        private static void BetterApproach()
        {
            Car car = null;

            try
            {
                car = new Car();
            }
            finally
            {
                car?.Dispose();
            }
        }

        /*using это синонимичная конструкция как в предыдущем методе try...finaly.
         Согласитесь что поприятней, гарантированно сработает Dispose() даже если
         возникнет исключение*/
        private static void TheBestApproach()
        {
            using (var car = new Car())
            {
            }
        }

        /*                                 ВНИМАНИЕ!!!                            */
        /*Есть еще один вариант который сочитает оба подхода: рассмотрен в Part3.
         С одной стороны как например в методе Approach() я могу в любой момент когда
         захочу вызвать Dispose(), а с другой стороны кто нить другой использующий наш класс
         может забыть вызвать метод Dispose() вручную и получить боль. Но есть подход сочетающий
         оба варианта предложенный Microsoft. Смотрите Part3*/
    }
}
